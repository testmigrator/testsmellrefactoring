Input Parameters:
Test Code:
 @Test
  public void testEntrySet() {
    JsonObject o = new JsonObject();
    assertThat(o.entrySet()).hasSize(0);

    o.addProperty("b", true);
    Set<?> expectedEntries = Collections.singleton(new SimpleEntry<>("b", new JsonPrimitive(true)));
    assertThat(o.entrySet()).isEqualTo(expectedEntries);
    assertThat(o.entrySet()).hasSize(1);

    o.addProperty("a", false);
    // Insertion order should be preserved by entrySet()
    List<?> expectedEntriesList =
        Arrays.asList(
            new SimpleEntry<>("b", new JsonPrimitive(true)),
            new SimpleEntry<>("a", new JsonPrimitive(false)));
    assertThat(new ArrayList<>(o.entrySet())).isEqualTo(expectedEntriesList);

    Iterator<Entry<String, JsonElement>> iterator = o.entrySet().iterator();
    // Test behavior of Entry.setValue
    for (int i = 0; i < o.size(); i++) {
      Entry<String, JsonElement> entry = iterator.next();
      entry.setValue(new JsonPrimitive(i));

      assertThat(entry.getValue()).isEqualTo(new JsonPrimitive(i));
    }

    expectedEntriesList =
        Arrays.asList(
            new SimpleEntry<>("b", new JsonPrimitive(0)),
            new SimpleEntry<>("a", new JsonPrimitive(1)));
    assertThat(new ArrayList<>(o.entrySet())).isEqualTo(expectedEntriesList);

    Entry<String, JsonElement> entry = o.entrySet().iterator().next();
    // null value is not permitted, only JsonNull is supported
    // This intentionally deviates from the behavior of the other JsonObject methods which
    // implicitly convert null -> JsonNull, to match more closely the contract of Map.Entry
    var e = assertThrows(NullPointerException.class, () -> entry.setValue(null));
    assertThat(e).hasMessageThat().isEqualTo("value == null");
    assertThat(entry.getValue()).isNotNull();

    o.addProperty("key1", 1);
    o.addProperty("key2", 2);

    Deque<?> expectedEntriesQueue =
        new ArrayDeque<>(
            Arrays.asList(
                new SimpleEntry<>("b", new JsonPrimitive(0)),
                new SimpleEntry<>("a", new JsonPrimitive(1)),
                new SimpleEntry<>("key1", new JsonPrimitive(1)),
                new SimpleEntry<>("key2", new JsonPrimitive(2))));
    // Note: Must wrap in ArrayList because Deque implementations do not implement `equals`
    assertThat(new ArrayList<>(o.entrySet())).isEqualTo(new ArrayList<>(expectedEntriesQueue));
    iterator = o.entrySet().iterator();

    // Remove entries one by one
    for (int i = o.size(); i >= 1; i--) {
      assertThat(iterator.hasNext()).isTrue();
      assertThat(iterator.next()).isEqualTo(expectedEntriesQueue.getFirst());
      iterator.remove();
      expectedEntriesQueue.removeFirst();

      assertThat(o.size()).isEqualTo(i - 1);
      assertThat(new ArrayList<>(o.entrySet())).isEqualTo(new ArrayList<>(expectedEntriesQueue));
    }
  }
Context: /com/google/gson/JsonObject
Smell List: ['Assertion_Roulette', 'Conditional_Test_Logic', 'Eager_Test', 'Duplicate_Assert']
Smell Description List: ['Test Smell Type：Assertion Roulette\n\nFeature:\nA test method contains more than one assertion statement without an explanation/message (parameter in the assertion method).\n', 'Test Smell Type：Conditional Test Logic\n\nFeature:\nA test method that contains one or more control statements (i.e if, switch, conditional expression, for, foreach and while statement).\n', 'Test Smell Type：Eager Test\n\nFeature:\nA test method contains multiple calls to multiple production methods.\n', 'Test Smell Type：Duplicate Assert\n\nFeature:\nA test method that contains more than one assertion statement with the same parameters.\n']
Refactoring DSL: ['RefactorRule:\n  SmellType: Assertion Roulette\n  Description: Add descriptive messages to assert statements to improve readability and maintainability.\n  Steps:\n    - Step:\n        Description: "Add descriptive message to each assert statement(except assertThat, assertThrows)."\n        Action: AddMessageToAssert\n        Parameters:\n          MessagePattern: "{assertionMessage}"\n  Example:\n    Before: |\n      @Test\n      public void T() {\n        stmt\n        assert_1\n        ...\n        assert_n\n        stmt\'\n      }\n    After: |\n      @Test\n      public void T() {\n        stmt\n        assert_1(..., "Descriptive message for assert statement")\n        ...\n        assert_n(..., "Descriptive message for assert statement")\n        stmt\'\n      }\n    Variables:\n      assertionMessage: "Descriptive message for assert statement"\n', 'RefactorRule:\n  SmellType: Conditional Test Logic\n  Description: "Extract complex control flow logic into separate helper methods to improve readability and testability."\n  Steps:\n    - Step:\n        Description: "Identify complex control flow constructs"\n        Action: IdentifyComplexControlFlow\n        Parameters:\n          TargetType: Method\n    - Step:\n        Description: "Extract control flow logic into a separate helper method"\n        Action: ExtractMethod\n        Parameters:\n          TargetType: Method\n          SourcePattern: |\n            (if|switch|for|while|do-while) ({condition}) {\n                {statements}\n            }\n          ExtractedMethod: |\n            private boolean/void helperMethodName() {\n                {extractedStatements}\n            }\n    - Step:\n        Description: "Replace complex control flow with a call to the helper method"\n        Action: ReplaceControlFlow\n        Parameters:\n          SourcePattern: |\n            (if|switch|for|while|do-while) ({condition}) {\n                {statements}\n            }\n          ReplacementPattern: |\n            helperMethodName();\n  Example:\n    Before: |\n      @Test\n      public void complexTest() {\n          if (condition1 && condition2) {\n              if (condition3) {\n                  doSomething();\n              } else {\n                  doSomethingElse();\n              }\n          } else {\n              doDefault();\n          }\n      }\n    After: |\n      private boolean isComplexConditionMet() {\n          return condition1 && condition2 && condition3;\n      }\n\n      private void handleComplexScenario() {\n          if (isComplexConditionMet()) {\n              doSomething();\n          } else {\n              doSomethingElse();\n          }\n      }\n\n      @Test\n      public void complexTest() {\n          handleComplexScenario();\n          doDefault();\n      }\n', 'RefactorRule:\n  SmellType: Eager Test\n  Description: "Refactor test methods to group related assertions logically and extract reusable setup logic into private methods."\n  Steps:\n    - Step1:\n        Description: "Extract shared setup logic into a reusable, private method and ensure it is used across all relevant tests."\n        Action: ExtractSetupMethod\n        Parameters:\n          Condition: "If multiple tests share the same setup logic."\n          MethodNamePattern: setupTest{OriginalMethodName}\n    - Step2:\n        Description: "Group related assertions into cohesive sub-tests while retaining necessary setup logic."\n        Action: GroupAssertions\n        Parameters:\n          GroupBy: LogicalConcern\n    - Step3:\n        Description: "Create new test methods for each cohesive group of assertions and ensure readability."\n        Action: CreateTestMethods\n        Parameters:\n          IncludeSetup: True\n          NamePattern: test{OriginalMethodName}_{Concern}\n  Example:\n    Before: |\n      @Test\n      public void testExample() {\n          setup();\n          assertEquals(1, methodA());\n          assertTrue(methodB());\n      }\n    After: |\n      private void setupTestExample() {\n          setup();\n      }\n\n      @Test\n      public void testExample_MethodA() {\n          setupTestExample();\n          assertEquals(1, methodA());\n      }\n\n      @Test\n      public void testExample_MethodB() {\n          setupTestExample();\n          assertTrue(methodB());\n      }\n  Variables:\n    OriginalMethodName: The name of the original test method.\n    LogicalConcern: The logical aspect tested (e.g., a specific API, validation, or behavior).\n', 'RefactorRule:\n  SmellType: Duplicate Assert\n  Description: "If the assertion logic is the same but tested with different inputs, convert the test to a parameterized test using JUnit 5\'s @CsvSource annotation. Otherwise, split the test into multiple separate methods, each containing a single assertion."\n  Steps:\n    - Step:\n        Description: "Check if there are multiple assertions testing the same condition"\n        Action: IdentifySameAssertions\n        Parameters:\n          SourcePattern: |\n\t          assert(expected, ...)\n\t          assert(expected, ...)\n    - Step:\n        Description: "Create new test methods if necessary to separate assertions for different inputs"\n        Action: SplitMethod\n        Parameters:\n          TargetType: Method\n\n    - Step:\n        Description: "Convert the test method to a parameterized test"\n        Action: ConvertToParameterizedTest\n        Parameters:\n          TargetType: Method\n    - Step:\n        Description: "Add @CsvSource annotation to declare parameterized values."\n        Action: AddAnnotation\n        Parameters:\n          TargetType: Method\n          Annotation: |\n            @CsvSource({\n              "{paramValues}"\n            })\n    - Step:\n        Description: "Refactor the test method to use parameterized values."\n        Action: RefactorMethod\n        Parameters:\n          SourcePattern: |\n            public void T() {\n              {originalStatements}\n            }\n          ReplacementPattern: |\n            public void T({parameterNames}) {\n              {refactoredStatements}\n            }\n  Example:\n    Before: |\n      @Test\n      public void T() {\n        assertEquals(expectedA, methodUnderTest(a));\n        assertEquals(expectedB, methodUnderTest(b));\n      }\n\n    After: |\n      @ParameterizedTest\n      @CsvSource({\n        "a, expectedA",\n        "b, expectedB"\n      })\n      public void T(String input, String expected) {\n        assertEquals(expected, methodUnderTest(input));\n      }\n']
Checkpoints: ['[ ] All assert statements have been added with clear explanatory messages.\n', '[ ] All conditional test logic has been refactored to use JUnit 5’s conditional test execution feature, with the condition verified in an external method assigned via the @EnabledIf annotation.\n', '[ ] All eager tests have been split into separate tests, each focusing on verifying a single API.\n', '[ ] All duplicate assertions have been refactored using JUnit 5 Parameterized Tests, where the lists of parameterizable values are declared in a specific annotation, and the test method is executed independently m times.\n']

Refactored Code: 
 
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.*;

public class JsonObjectTest {

  private JsonObject o;

  @BeforeEach
  public void setUp() {
    o = new JsonObject();
  }

  @Test
  public void testEmptyEntrySet() {
    assertThat(o.entrySet()).hasSize(0, "Entry set size should be 0 for an empty JsonObject");
  }

  @Test
  public void testSingleEntrySet() {
    o.addProperty("b", true);
    Set<?> expectedEntries = Collections.singleton(new SimpleEntry<>("b", new JsonPrimitive(true)));
    assertThat(o.entrySet()).isEqualTo(expectedEntries, "Entry set should contain the added entry");
    assertThat(o.entrySet()).hasSize(1, "Entry set size should be 1 after adding one entry");
  }

  @Test
  public void testMultipleEntriesPreserveOrder() {
    o.addProperty("b", true);
    o.addProperty("a", false);
    List<?> expectedEntriesList = Arrays.asList(
        new SimpleEntry<>("b", new JsonPrimitive(true)),
        new SimpleEntry<>("a", new JsonPrimitive(false))
    );
    assertThat(new ArrayList<>(o.entrySet())).isEqualTo(expectedEntriesList, "Entry set should preserve insertion order");
  }

  @ParameterizedTest
  @CsvSource({
      "b, 0",
      "a, 1"
  })
  public void testSetValue(String key, int value) {
    o.addProperty("b", true);
    o.addProperty("a", false);
    Iterator<Entry<String, JsonElement>> iterator = o.entrySet().iterator();
    while (iterator.hasNext()) {
      Entry<String, JsonElement> entry = iterator.next();
      if (entry.getKey().equals(key)) {
        entry.setValue(new JsonPrimitive(value));
        assertThat(entry.getValue()).isEqualTo(new JsonPrimitive(value), "Value should be updated correctly");
      }
    }
  }

  @Test
  public void testSetValueNull() {
    o.addProperty("b", true);
    Entry<String, JsonElement> entry = o.entrySet().iterator().next();
    var e = assertThatThrownBy(() -> entry.setValue(null)).isInstanceOf(NullPointerException.class)
        .withFailMessage("Setting null value should throw NullPointerException");
    assertThat(e).hasMessageThat().isEqualTo("value == null", "Exception message should match expected message");
  }

  @Test
  public void testRemoveEntries() {
    o.addProperty("b", true);
    o.addProperty("a", false);
    o.addProperty("key1", 1);
    o.addProperty("key2", 2);

    Deque<?> expectedEntriesQueue = new ArrayDeque<>(Arrays.asList(
        new SimpleEntry<>("b", new JsonPrimitive(true)),
        new SimpleEntry<>("a", new JsonPrimitive(false)),
        new SimpleEntry<>("key1", new JsonPrimitive(1)),
        new SimpleEntry<>("key2", new JsonPrimitive(2))
    ));

    Iterator<Entry<String, JsonElement>> iterator = o.entrySet().iterator();

    for (int i = o.size(); i >= 1; i--) {
      assertThat(iterator.hasNext()).isTrue("Iterator should have next element");
      assertThat(iterator.next()).isEqualTo(expectedEntriesQueue.getFirst(), "Removed entry should match expected entry");
      iterator.remove();
      expectedEntriesQueue.removeFirst();

      assertThat(o.size()).isEqualTo(i - 1, "Size should decrease after removal");
      assertThat(new ArrayList<>(o.entrySet())).isEqualTo(new ArrayList<>(expectedEntriesQueue), "Entry set should match expected entries after removal");
    }
  }
}



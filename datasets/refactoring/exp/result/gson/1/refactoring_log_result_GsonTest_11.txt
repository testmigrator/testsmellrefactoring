Input Parameters:
Test Code:
 @Test
  public void testNewBuilderModification() {
    Gson gson =
        new GsonBuilder()
            .registerTypeAdapter(
                CustomClass1.class,
                new TypeAdapter<CustomClass1>() {
                  @Override
                  public CustomClass1 read(JsonReader in) throws IOException {
                    throw new UnsupportedOperationException();
                  }

                  @Override
                  public void write(JsonWriter out, CustomClass1 value) throws IOException {
                    out.value("custom-adapter");
                  }
                })
            .registerTypeHierarchyAdapter(
                CustomClass2.class,
                new JsonSerializer<CustomClass2>() {
                  @Override
                  public JsonElement serialize(
                      CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {
                    return new JsonPrimitive("custom-hierarchy-adapter");
                  }
                })
            .registerTypeAdapter(
                CustomClass3.class,
                new InstanceCreator<CustomClass3>() {
                  @Override
                  public CustomClass3 createInstance(Type type) {
                    return new CustomClass3("custom-instance");
                  }
                })
            .create();

    assertCustomGson(gson);

    // Modify `gson.newBuilder()`
    GsonBuilder gsonBuilder = gson.newBuilder();
    gsonBuilder.registerTypeAdapter(
        CustomClass1.class,
        new TypeAdapter<CustomClass1>() {
          @Override
          public CustomClass1 read(JsonReader in) throws IOException {
            throw new UnsupportedOperationException();
          }

          @Override
          public void write(JsonWriter out, CustomClass1 value) throws IOException {
            out.value("overwritten custom-adapter");
          }
        });
    gsonBuilder.registerTypeHierarchyAdapter(
        CustomClass2.class,
        new JsonSerializer<CustomClass2>() {
          @Override
          public JsonElement serialize(
              CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {
            return new JsonPrimitive("overwritten custom-hierarchy-adapter");
          }
        });
    gsonBuilder.registerTypeAdapter(
        CustomClass3.class,
        new InstanceCreator<CustomClass3>() {
          @Override
          public CustomClass3 createInstance(Type type) {
            return new CustomClass3("overwritten custom-instance");
          }
        });

    // `gson` object should not have been affected by changes to new GsonBuilder
    assertCustomGson(gson);
    // New GsonBuilder based on `gson` should not have been affected either
    assertCustomGson(gson.newBuilder().create());

    // But new Gson instance from `gsonBuilder` should be affected by changes
    Gson otherGson = gsonBuilder.create();
    String json1 = otherGson.toJson(new CustomClass1());
    assertThat(json1).isEqualTo("\"overwritten custom-adapter\"");

    String json2 = otherGson.toJson(new CustomClass2());
    assertThat(json2).isEqualTo("\"overwritten custom-hierarchy-adapter\"");

    CustomClass3 customClass3 = otherGson.fromJson("{}", CustomClass3.class);
    assertThat(customClass3.s).isEqualTo("overwritten custom-instance");
  }
Context: /com/google/gson/Gson
Smell List: ['Assertion_Roulette', 'Eager_Test']
Smell Description List: ['Test Smell Type：Assertion Roulette\n\nFeature:\nA test method contains more than one assertion statement without an explanation/message (parameter in the assertion method).\n', 'Test Smell Type：Eager Test\n\nFeature:\nA test method contains multiple calls to multiple production methods.\n']
Refactoring DSL: ['RefactorRule:\n  SmellType: Assertion Roulette\n  Description: Add descriptive messages to assert statements to improve readability and maintainability.\n  Steps:\n    - Step:\n        Description: "Add descriptive message to each assert statement(except assertThat, assertThrows)."\n        Action: AddMessageToAssert\n        Parameters:\n          MessagePattern: "{assertionMessage}"\n  Example:\n    Before: |\n      @Test\n      public void T() {\n        stmt\n        assert_1\n        ...\n        assert_n\n        stmt\'\n      }\n    After: |\n      @Test\n      public void T() {\n        stmt\n        assert_1(..., "Descriptive message for assert statement")\n        ...\n        assert_n(..., "Descriptive message for assert statement")\n        stmt\'\n      }\n    Variables:\n      assertionMessage: "Descriptive message for assert statement"\n', 'RefactorRule:\n  SmellType: Eager Test\n  Description: "Refactor test methods to group related assertions logically and extract reusable setup logic into private methods."\n  Steps:\n    - Step1:\n        Description: "Extract shared setup logic into a reusable, private method and ensure it is used across all relevant tests."\n        Action: ExtractSetupMethod\n        Parameters:\n          Condition: "If multiple tests share the same setup logic."\n          MethodNamePattern: setupTest{OriginalMethodName}\n    - Step2:\n        Description: "Group related assertions into cohesive sub-tests while retaining necessary setup logic."\n        Action: GroupAssertions\n        Parameters:\n          GroupBy: LogicalConcern\n    - Step3:\n        Description: "Create new test methods for each cohesive group of assertions and ensure readability."\n        Action: CreateTestMethods\n        Parameters:\n          IncludeSetup: True\n          NamePattern: test{OriginalMethodName}_{Concern}\n  Example:\n    Before: |\n      @Test\n      public void testExample() {\n          setup();\n          assertEquals(1, methodA());\n          assertTrue(methodB());\n      }\n    After: |\n      private void setupTestExample() {\n          setup();\n      }\n\n      @Test\n      public void testExample_MethodA() {\n          setupTestExample();\n          assertEquals(1, methodA());\n      }\n\n      @Test\n      public void testExample_MethodB() {\n          setupTestExample();\n          assertTrue(methodB());\n      }\n  Variables:\n    OriginalMethodName: The name of the original test method.\n    LogicalConcern: The logical aspect tested (e.g., a specific API, validation, or behavior).\n']
Checkpoints: ['[ ] All assert statements have been added with clear explanatory messages.\n', '[ ] All eager tests have been split into separate tests, each focusing on verifying a single API.\n']

Refactored Code: 
 
private Gson createCustomGson() {
    return new GsonBuilder()
        .registerTypeAdapter(
            CustomClass1.class,
            new TypeAdapter<CustomClass1>() {
              @Override
              public CustomClass1 read(JsonReader in) throws IOException {
                throw new UnsupportedOperationException();
              }

              @Override
              public void write(JsonWriter out, CustomClass1 value) throws IOException {
                out.value("custom-adapter");
              }
            })
        .registerTypeHierarchyAdapter(
            CustomClass2.class,
            new JsonSerializer<CustomClass2>() {
              @Override
              public JsonElement serialize(
                  CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {
                return new JsonPrimitive("custom-hierarchy-adapter");
              }
            })
        .registerTypeAdapter(
            CustomClass3.class,
            new InstanceCreator<CustomClass3>() {
              @Override
              public CustomClass3 createInstance(Type type) {
                return new CustomClass3("custom-instance");
              }
            })
        .create();
}

private GsonBuilder modifyGsonBuilder(GsonBuilder gsonBuilder) {
    return gsonBuilder
        .registerTypeAdapter(
            CustomClass1.class,
            new TypeAdapter<CustomClass1>() {
              @Override
              public CustomClass1 read(JsonReader in) throws IOException {
                throw new UnsupportedOperationException();
              }

              @Override
              public void write(JsonWriter out, CustomClass1 value) throws IOException {
                out.value("overwritten custom-adapter");
              }
            })
        .registerTypeHierarchyAdapter(
            CustomClass2.class,
            new JsonSerializer<CustomClass2>() {
              @Override
              public JsonElement serialize(
                  CustomClass2 src, Type typeOfSrc, JsonSerializationContext context) {
                return new JsonPrimitive("overwritten custom-hierarchy-adapter");
              }
            })
        .registerTypeAdapter(
            CustomClass3.class,
            new InstanceCreator<CustomClass3>() {
              @Override
              public CustomClass3 createInstance(Type type) {
                return new CustomClass3("overwritten custom-instance");
              }
            });
}

@Test
public void testNewBuilderModification_CustomGsonUnaffected() {
    Gson gson = createCustomGson();
    assertCustomGson(gson, "Initial custom Gson should match expected configuration");
    GsonBuilder gsonBuilder = gson.newBuilder();
    modifyGsonBuilder(gsonBuilder);
    assertCustomGson(gson, "Original Gson should remain unaffected after modifying builder");
    assertCustomGson(gson.newBuilder().create(), "New Gson from original builder should remain unaffected");
}

@Test
public void testNewBuilderModification_ModifiedGsonAffected() {
    Gson gson = createCustomGson();
    GsonBuilder gsonBuilder = gson.newBuilder();
    GsonBuilder modifiedGsonBuilder = modifyGsonBuilder(gsonBuilder);
    Gson otherGson = modifiedGsonBuilder.create();

    String json1 = otherGson.toJson(new CustomClass1());
    assertThat(json1).isEqualTo("\"overwritten custom-adapter\"").withFailMessage("CustomClass1 serialization should be overwritten");

    String json2 = otherGson.toJson(new CustomClass2());
    assertThat(json2).isEqualTo("\"overwritten custom-hierarchy-adapter\"").withFailMessage("CustomClass2 serialization should be overwritten");

    CustomClass3 customClass3 = otherGson.fromJson("{}", CustomClass3.class);
    assertThat(customClass3.s).isEqualTo("overwritten custom-instance").withFailMessage("CustomClass3 deserialization should be overwritten");
}


